           (*-------------------------------------------*            |                                           |            |  Specification for Parallel Controller    |            |                                           |            *-------------------------------------------*)theory MBP_specimports CSP_semantics MBP_basebegin(*************************************************************         1. Spec         2.          3.          4.  *************************************************************)datatype SpecName = Seq nodes edges nodesprimrec  SpecDef :: "SpecName => (SpecName, Event) proc"  where  "SpecDef (Seq Blks Deps S)        = ((S = Blks) &> finish -> STOP)          [+] ((~(S = Blks)) &> ([Nat] n:enable Blks Deps S .. blk n -> $Seq Blks Deps (S Un {n})))"overloading SpecPNfun ==   "PNfun :: SpecName => (SpecName, Event) proc"  begindefinition "PNfun == SpecDef"enddeclare SpecPNfun_def [simp]definition  SeqCtrl :: "nodes => edges => (SpecName,Event) proc"  where  SeqCtrl_def : "SeqCtrl Blks Deps  == $Seq Blks Deps {}"primrec  blk_traces  :: "Event ev_list => nat set => bool" where   "blk_traces [] = (%S. if S={} then True else False)" | "blk_traces (e#t) = (%S. EX n. n:S & e = Ev (blk n) & blk_traces t (S-{n}))"(* ----------------------------------------- * |                    lemmas                 | * ----------------------------------------- *)lemma Seq_trn_blk:  "S ~= Blks ==>    n \<in> enable Blks Deps S ==>   $Seq Blks Deps S ---(Ev (blk n))---> $Seq Blks Deps (insert n S)"  apply (rule PName)  apply (simp)  apply (rule ExtCh2)  apply (rule If1)  apply (rule conjI)   apply (rule NatExtCh1)   apply (rule conjI)    apply (rule Prefix)   apply (simp)  apply (simp)  donelemma Seq_trn_finish:  "$Seq Blks Deps Blks ---(Ev finish)---> STOP"  apply (rule PName)  apply (simp)  apply (rule ExtCh1)  apply (rule If1)  apply (rule conjI)   apply (rule Prefix)  apply (simp)  donelemma Seq_trn:  "ALL S e P'.   S <= Blks   -->   $Seq Blks Deps S ---e---> P'   --> (if S = Blks then e = Ev finish & P' = STOP         else EX n. n : enable Blks Deps S & e = Ev (blk n)              & P' = $Seq Blks Deps (insert n S))"  apply (intro allI impI)  apply (case_tac "S = Blks")  apply (simp)  apply (erule trn.cases,auto)+  donelemma Seq_trn_ex:  "(S = Blks | (EX n. n : enable Blks Deps S))   ==>   EX a::Event. $Seq Blks Deps S ---(Ev a)--->+"  apply (simp add: trn_ex_def)  apply (case_tac "S = Blks")   apply (rule_tac x="finish" in exI)   apply (rule_tac x="STOP" in exI)   apply (simp add: Seq_trn_finish)   apply (simp)   apply (erule exE)   apply (rule_tac x="blk n" in exI)   apply (rule_tac x="$Seq Blks Deps (insert n S)" in exI)   apply (simp add: Seq_trn_blk)  donelemma Seq_trns:  "ALL t S P'.   S <= Blks   -->   $Seq Blks Deps S ---t--->> P'   -->    (EX S'. S' <= Blks & S Int S' = {} & (      (blk_traces t S' & P' = $Seq Blks Deps (S Un S'))    | (EX t'. blk_traces t' S' & t = t'@[Ev finish] & P' = STOP)))"  apply (rule allI)  apply (induct_tac t)  (* base case *)  apply (simp add: seq_trn_nil)  (* step case *)  apply (simp)  apply (intro allI impI)  apply (rename_tac a t1 S P')  apply (simp add: seq_trn_step)  apply (elim exE conjE)  apply (insert Seq_trn[of Blks Deps])  apply (rotate_tac -1)  apply (drule_tac x="S" in spec)  apply (drule_tac x="a" in spec)  apply (drule_tac x="P1" in spec)  apply (case_tac "S = Blks")   (* S = Blks *)   apply (simp)   apply (drule_tac x="S" in spec)   apply (simp add: seq_trn_STOP)   (* S ~= Blks *)   apply (simp)   apply (elim exE conjE)   apply (simp)   apply (drule_tac x="insert n S" in spec)   apply (drule mp)    apply (simp add: enable_def)   apply (drule_tac x="P'" in spec)   apply (simp)   apply (elim disjE exE conjE)    apply (simp)    apply (rule_tac x="insert n S'" in exI)    apply (simp add: enable_def)    apply (simp)    apply (rule_tac x="insert n S'" in exI)    apply (simp add: enable_def)  doneend