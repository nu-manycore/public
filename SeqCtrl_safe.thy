           (*-------------------------------------------*            |                                           |            |         Safety of Specifications          |            |                                           |            *-------------------------------------------*)theory SeqCtrl_safeimports MBP_Spec CSP_semanticsbegin(*************************************************************         1. SeqCtrl: safe order         2.          3.          4.  *************************************************************)(* ----------------------------------------- * |                    lemmas                 | * ----------------------------------------- *)lemma Seq_blk:"ALL a P' Blks Deps S. $Seq Blks Deps S ---a---> P'--> S <= Blks  --> (if (S = Blks) then (a = Ev finish & P' = STOP)   else (EX n. n:enable Blks Deps S & a = Ev (blk n) &   P' = $Seq Blks Deps (S Un {n})))"  apply (auto)    apply (erule trn.cases, auto)+  (* all cases are checked for ||| *)  done(* ----------------------------------------- * |                    lemmas                 | * ----------------------------------------- *)lemma Seqctrl_safe_induct:"ALL s k t P' S. k < length t -->       t = rem_tau s -->       S <= Blks -->       $Seq Blks Deps S ---s--->> P' -->       (EX n. t!k = blk n & src Blks Deps n <= dones t k Un S) | (t!k = finish & P' = STOP) "  apply (rule allI)  apply (induct_tac s)   apply (simp)  apply (simp)  apply (rule allI)  apply (rule impI)  apply (rule allI)  apply (rule allI)  apply (rule impI)  apply (rename_tac a t k P' S)  apply (simp add: seq_trn_step)  apply (rule impI)  apply (erule exE)  apply (erule conjE)  apply (insert Seq_blk)  apply (drule_tac x="a" in spec)  apply (drule_tac x="P1" in spec)  apply (drule_tac x="Blks" in spec)  apply (drule_tac x="Deps" in spec)  apply (drule_tac x="S" in spec)  apply (simp)  apply (case_tac "S = Blks")(*case S=Blks*)   apply (simp)   apply (rule disjI2)   apply (subgoal_tac "t = [] & P' = STOP")    apply (simp)   apply (simp add: stop_seq_trn)(*case ~S=Blks*)  apply (simp)  apply (elim exE conjE disjE)  apply (simp)(*case k=0*)  apply (case_tac "k = 0")   apply (simp)   apply (simp add:dones_def)  apply (simp add:enable_def)(*case k>0*)  apply (drule_tac x="k-1" in spec)  apply (simp)  (*apply (drule mp)*)   apply(subgoal_tac "EX k'. k = Suc k'")    apply (erule exE)   apply (simp)  apply (drule_tac x="P'" in spec)  apply (drule_tac x="insert n S" in spec)   apply (simp)   apply (drule mp)   apply (simp add:enable_def)   apply (elim exE conjE disjE)    apply (rule disjI1)    apply (rule_tac x="na" in exI)    apply (simp)    apply (rule order_trans)     apply (simp)    apply (simp only: dones_insert)  (* apply(rule disjI2)*)   apply (simp)   apply (simp add: gr0_implies_Suc)  donelemma Seqctrl_safe_event_induct:"ALL s k t P' S. k < length t -->       t = rem_tau s -->       S <= Blks -->       $Seq Blks Deps S ---s--->> P' -->       (EX n. t!k = blk n) | (t!k = finish & P' = STOP)"  apply (rule allI)  apply (induct_tac s)   apply (simp)  apply (simp)  apply (rule allI)  apply (rule impI)  apply (rule allI)  apply (rule allI)  apply (rule impI)  apply (rename_tac a t k P' S)  apply (simp add: seq_trn_step)  apply (rule impI)  apply (erule exE)  apply (erule conjE)  apply (insert Seq_blk)  apply (drule_tac x="a" in spec)  apply (drule_tac x="P1" in spec)  apply (drule_tac x="Blks" in spec)  apply (drule_tac x="Deps" in spec)  apply (drule_tac x="S" in spec)  apply (simp)  apply (case_tac "S = Blks")(*case S=Blks*)   apply (simp)   apply (rule disjI2)  apply(subgoal_tac "t = [] & P' = STOP")    apply (simp)   apply (simp add: stop_seq_trn)  apply (simp)  apply (elim exE conjE disjE)  apply (simp)  apply (case_tac "k = 0")   apply (simp)  apply (drule_tac x="k-1" in spec)  apply (simp)  apply (drule mp)   apply(subgoal_tac "EX k'. k = Suc k'")    apply (erule exE)    apply (simp)   apply (simp add: gr0_implies_Suc)  apply (drule_tac x="P'" in spec)  apply (drule_tac x="insert n S" in spec)  apply (simp)  apply (simp add:enable_def)  done  lemma Seqctrl_safe_event:" t:traces(SeqCtrl Blks Deps) ==> k < length(t) ==> (EX n. t!k = blk n | t!k = finish)"  apply(simp add: traces_def)   apply(erule exE)  apply(erule conjE)  apply(erule exE)  apply (rename_tac P')  apply (simp add: SeqCtrl_def)  apply (insert Seqctrl_safe_event_induct[of Blks Deps])  apply (drule_tac x="s" in spec)  apply (drule_tac x="k" in spec)  apply (drule_tac x="t" in spec)  apply (drule_tac x="P'" in spec)  apply (drule_tac x="{}" in spec)  apply (simp)  apply (elim exE conjE disjE)  apply (simp)  apply (simp)  done(* ----------------------------------------- * |          tamon Proposition 5.1             | * ----------------------------------------- *)lemma Seqctrl_safe:"t:traces(SeqCtrl Blks Deps) ==> k < length(t)  ==> (EX n. t!k = blk n & src Blks Deps n <= dones t k) | t!k = finish"  apply (simp add:traces_def)  apply (elim exE conjE)  apply (simp add:SeqCtrl_def)  apply (insert Seqctrl_safe_induct  [of Blks Deps])  apply (drule_tac x="s" in spec)  apply (drule_tac x="k" in spec)  apply (drule_tac x="t" in spec)  apply (drule_tac x="x" in spec)  apply (drule_tac x="{}" in spec)  apply (simp)  apply (elim exE conjE disjE)   apply (simp)  apply (simp)  doneend